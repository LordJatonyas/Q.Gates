# -*- coding: utf-8 -*-
"""
Created on Tue Jun  2 12:32:15 2020
@author: mert4152
"""

import os, json
import time
from Calc_Potential_New import calc_potential_eachgate
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import networkx as nx
from networkx.utils import pairwise
from scipy.signal import convolve
from scipy.signal import find_peaks
from skimage.segmentation import flood_fill
import copy
from multiprocessing import Pool
import pickle
from imageio.v2 import imread

class potential_path():
    def __init__(self):
        self.pot_dis = 1184
        self.information = False
        self.f_level = 0
        self.add_disorder = False
        self.screen = True
        self.add_kernel = True
        self.carrier_charge_sign = 1 # (1: holes, -1:electrons)
        self.source_list = None
        self.physics_potential = 0
        self.pot_with_applied_voltages = []

    """Plotting I used for potential and density, you can ignore this"""
    def plot_potential(self,img,title,save,mV=False):
        class OOMFormatter(matplotlib.ticker.ScalarFormatter):
            def __init__(self, order=0, fformat="%1.1f", offset=True, mathText=True):
                self.oom = order
                self.fformat = fformat
                matplotlib.ticker.ScalarFormatter.__init__(self,useOffset=offset,useMathText=mathText)
            def _set_order_of_magnitude(self):
                self.orderOfMagnitude = self.oom
            def _set_format(self, vmin=None, vmax=None):
                self.format = self.fformat
                if self._useMathText:
                    self.format = r'$\mathdefault{%s}$' % self.format
        #E7165A
        #e635f9
        col = ['#1BE7D0','#e635f9','#DFFF00','#EFFFFE']
        cmap = plt.get_cmap("jet",30)
        im_ratio = img.shape[0]/img.shape[1]
        plt.style.use("dark_background")
        im = plt.imshow(img,cmap=cmap,extent=(0, img.shape[1], 0, img.shape[0]))

        plt.title(title, fontsize = 14,color=col[0])
        plt.xlabel("x ["r'$px$'"]", fontsize = 14,color=col[0])
        plt.ylabel("y ["r'$px$'"]", fontsize = 14,color=col[1])

        im.axes.spines.left.set_color(col[1])
        im.axes.spines.right.set_color(col[1])
        im.axes.spines.top.set_color(col[0])
        im.axes.spines.bottom.set_color(col[0])
        im.axes.tick_params(axis="x",color=col[0], labelcolor=col[0])
        im.axes.tick_params(axis="y",color=col[1], labelcolor=col[1])

        min = np.amin(np.array(img))
        max = np.amax(np.array(img))

        if mV == False:
            if max < 10**6:
                ticks = np.linspace(1000,int(np.floor(max/1000)*1000),int(np.floor(max/1000)))
                ticks = np.insert(ticks,0,min)
                ticks = np.append(ticks,max)
            else:
                ticks = np.linspace(min,max,10)
        else:
            ticks = np.linspace(500,int(np.floor(max/1000)*1000),int(np.floor(max/1000)*2))[:-1]
            ticks = np.insert(ticks,0,min)
            ticks = np.append(ticks,max)

        cb = plt.colorbar(im,fraction = 0.047*im_ratio,ticks=ticks,orientation="vertical",format=OOMFormatter(3))
        cb.ax.yaxis.set_tick_params(color=col[2])
        cb.ax.yaxis.get_offset_text().set_color(col[2])

        cb.outline.set_edgecolor(color=col[2])
        plt.setp(plt.getp(cb.ax.axes, 'yticklabels'), color=col[2])
        if mV == False:
            cb.ax.set_ylabel("Potential ["+r'$V$' "]", fontsize = 14,labelpad=10,color=col[2])
        else:
            cb.ax.set_ylabel("Potential ["+r'$mV$' "]", fontsize = 14,labelpad=10,color=col[2])
        plt.savefig(save,bbox_inches='tight',transparent=True,facecolor="black")
        plt.close()

    """This calculates potential of gates with applied gate voltages"""
    def weighted_potential(self,potential):
        # Load potential from each gate from file
        self.potential = potential
        # Weighted sum of potentials (set to 10V hence divide by 10000mV)
        pot_summa = np.sum(self.potential, axis=2)
        #self.plot_potential(pot_summa,title="Potential generated by gates' design",save="img/cmap_gate_potential.pdf")

        pot_sum = np.tensordot(self.potential,self.gate_volt/10000,axes=((2),(0)))
        #self.plot_potential(pot_sum,title="Potential with applied gate voltages",save="img/cmap_applied_gate_potential.pdf",mV=True)

        self.pot_with_applied_voltages = pot_sum

        return pot_sum

    #############################################################################
    def coulomb(self,X, Y, x, y):
        """ Change relative permitivity """
        # Relative permittivity
        e_r = 12.9
        # Total permittivity
        epsilon = 8.85E-12 * e_r
        # Coulomb Constant
        k = 1 / (4 * np.pi * epsilon)
        # Depth of 2DEG
        """Not any charges, so unnecessary unless there is oxide layer on the surface, maybe Vc unnecessary"""
        """Change the depth of 2DEG"""
        # Peak electron density is not exactly on the interface
        displace = 5
        d = (110 + displace) * 1E-9
        # Height of Donors
        h = (40 + displace) * 1E-9

        # Calculate distance from point charge on x-y plane
        r = np.sqrt(h ** 2 + (X - x) ** 2 + (Y - y) ** 2)
        r_mir = np.sqrt((2 * d - h) ** 2 + (X - x) ** 2 + (Y - y) ** 2)
        # Calculate potential (Gauss' Law)
        phi = k * (1 / r - 1 / r_mir)

        return phi

    """This one is used for calculating the density of SiGe device"""
    def coulomb_scr(self,X, Y, x, y):
        """ Change relative permitivity """
        # Relative permittivity
        e_r = 14.85
        # Total permittivity
        epsilon = 8.85E-12 * e_r
        # Coulomb Constant
        k = 1 / (4 * np.pi * epsilon)
        # Peak electron density is not exactly on the interface
        displace = 2

        """Change the depth of 2DEG"""
        # Depth of 2DEG
        d = (8 + displace) * 1E-9
        # Calculate distance from point charge on x-y plane
        r = np.sqrt((X - x) ** 2 + (Y - y) ** 2)
        r_mir = np.sqrt((2 * d) ** 2 + (X - x) ** 2 + (Y - y) ** 2)
        # Calculate potential (Gauss' Law)
        phi = k * (1 / r - 1 / r_mir)

        return phi

    def kernel_calc(self,array, dx, dy, screen):
        # Returns kernel for convolutions
        y_n, x_n = array.shape
        if screen == True:
            xr, yr = x_n * dx , y_n * dy
        else:
            # Choose different range for disorder
            xr, yr = x_n * dx / 0.5, y_n * dy / 0.5

        x = np.arange(dx, xr, dx)
        y = np.arange(dy, yr, dy)

        x = np.concatenate([x[::-1], [dx / 2.], x])
        y = np.concatenate([y[::-1], [dy / 2.], y])

        X, Y = np.meshgrid(x, y)
        if screen == True:
            kernel = self.coulomb_scr(X, Y, 0, 0)
        else:
            kernel = self.coulomb(X, Y, 0, 0)

        return kernel

    """Disroder is not used and I didnt test it much on SiGe, you can try it if you want"""
    def disorder(self, pot):
        # Returns disorder potential
        scale_x, scale_y = self.scale[0], self.scale[1]
        # Calculate Coulomb Kernel
        kernel = self.kernel_calc(pot, scale_x, scale_y, screen=False)

        N_0, M_0 = pot.shape[0], pot.shape[1]
        N = kernel.shape[0]
        M = kernel.shape[1]

        # Number of donors
        area = M * scale_x * N * scale_y  # m^2
        # Fraction of donors which are ionised
        frac_ion = 0.202
        # Donor density (experimental)
        density = 6.2E16  # m^-2
        p_dis = np.int(area * density * frac_ion)

        num_points = N * M
        # Random Donor Locations
        donor_idxs = np.random.randint(num_points, size=p_dis)
        donor_map = np.bincount(donor_idxs, minlength=N * M).reshape(N, M)
        # Multiply by magnitude of electron charge
        charge = donor_map * 1.6E-19
        # Convolution using Coulomb Kernel
        dis = convolve(charge, kernel, mode='same')
        # Return array of correct size
        N_cut, M_cut = int((N - N_0) / 2), int((M - M_0) / 2)
        dis = dis[N_cut:N - N_cut, M_cut:M - M_cut]

        dis = dis * 1E3  # mV

        return dis

    def path_find(self, energy):
        # Find minimax path from source to drain
        m, n = energy.shape[:2]

        # Create graph from pixels, nearest neighbour connections
        G = nx.generators.lattice.grid_2d_graph(m, n)
        [G.add_node(node, val=energy[node]) for node in G.nodes]

        rows = list(range(m))
        cols = list(range(n))

        G.add_edges_from(((i, j), (pi, pj))
                         for pi, i in pairwise(rows) for pj, j in pairwise(cols))
        G.add_edges_from(((pi, j), (i, pj))
                         for pi, i in pairwise(rows) for pj, j in pairwise(cols))

        G.add_edges_from(((pi, pj), (i, j))
                         for pi, i in pairwise(rows) for pj, j in pairwise(cols))
        G.add_edges_from(((i, pj), (pi, j))
                         for pi, i in pairwise(rows) for pj, j in pairwise(cols))

        # Add weights based on potential different between nodes

        energy = energy - np.min(energy) # to make minimax path work (all >= zero)
        [G.add_edge(n_from, n_to, weight=0.5 * (np.abs(energy[n_from] + energy[n_to]))) for n_from, n_to in G.edges]

        # MST
        T = nx.algorithms.tree.mst.minimum_spanning_tree(G)
        # Start and stop points
        begin = (self.source[0], self.source[1])
        end = (self.drain[0], self.drain[1])
        # Find path
        path = nx.dijkstra_path(T, source=begin, target=end)
        # 1D path potential
        path = np.array(path)
        # 2D path coordinates
        path_map = np.zeros_like(energy)
        path_map[path[:, 0], path[:, 1]] = 1

        return path, path_map

    def minimax_point(self):
        # Estimate Fermi level based on this being a pinch-off configuration
        one_d_path = self.pot_path[20:-20]
        path = self.path_coords[20:-20]

        minimax = np.max(one_d_path)
        loc = np.argmax(one_d_path)
        max_point = [path[loc,1],path[loc,0]]

        return minimax,max_point

    def TF_electron(self,pot,mu=0):
        """Change m for light holes (possible mix of heavy holes)"""
        # Thomas Fermi local density
        h_bar = 1.05E-34 #J
        m_eff = 0.067 # light hole effective mass in Ge, 0.28 for heavy holes approximately
        m = 9.11E-31 * m_eff # kg
        e = 1.6E-19 # To convert to J
        # Chemical potential mu, mV
        # Degeneracy
        degen = 2
        n = degen*(e*m/(np.pi*h_bar**2)) * (mu+pot) * (1E-3) * np.heaviside(mu+pot,1)
        #n = degen*(m_h*kb*T/(np.pi*h_bar**2))**(3/2)np.exp()
        #n = 1.1*10**12*10**(4)
        return n

    def TF_holes(self,pot,mu=0):
        h_bar = 1.05E-34 #J
        m_eff = 0.28 # 0.05 light hole effective mass in Ge, 0.28 for heavy holes approximately
        m = 9.11E-31 * m_eff # kg
        e = 1.6E-19 # To convert to J
        degen = 4
        n = degen*(e*m/(np.pi*h_bar**2)) * (mu-pot) * (1E-3) * np.heaviside(mu-pot,1)
        return n

    def screening_potential(self,e_den_m2):
        scale_x,scale_y = self.scale[0],self.scale[1]

        # Charge
        q = self.carrier_charge_sign*1.6E-19
        unit_a = scale_x*scale_y
        charge = unit_a*e_den_m2*q
        scr = convolve(charge,self.K,mode='same')

        # mV
        scr = scr*1E3
        return scr

    """Calculates the density based on potential"""
    def screening(self,pot_og):
        if self.information==True:
            print('\nScreening')
        # Length scales
        scale_x,scale_y = self.scale[0],self.scale[1]

        # Maximum number of iterations
        N_it = 200
        # Mixing Parameter alpha
        alpha = np.ones(N_it)*0.01

        # Convergence Error Threshold
        if self.add_disorder==True:
            convergence = 10E-3
        else:
            convergence = 5E-3

        N = pot_og.shape[0]
        M = pot_og.shape[1]

        # Expand for boundary effects
        k=4
        pot_og = np.pad(pot_og,pad_width=((int(N/k),int(N/k)),(int(M/k),int(M/k))),mode='reflect')
        pot_tot = pot_og
        start = time.time()
        if self.add_kernel==True:
            self.K = self.kernel_calc(pot_tot,scale_x,scale_y,screen=True)
        end = time.time()
        if self.information==True:
            print('Kernel Time:\t%.3f s' %(end-start))
            print('Iteration\tError')

        # Relaxation Loop
        for i in range(N_it):
            # Electron Density
            e_den = self.TF_holes(pot_tot,self.f_level)
            #print('\nMean Electron Density:\t\t%.3e m^-2' %np.mean(e_den))
            # Screening Potential
            phi_screen = self.screening_potential(e_den)
            # Add screening to original bare potential
            pot_tot_cal = pot_og + phi_screen
            # Under Relaxation
            pot_tot_update = (1-alpha[i])*pot_tot + alpha[i]*pot_tot_cal
            # Convergence Error
            distance = np.abs(pot_tot-pot_tot_update)
            err = np.mean(distance)
            # New for next iteration
            pot_tot = pot_tot_update

            if i%10==0 and self.information==True:
                print('   %d' %i,'\t\t%.5f' %err)

            if err<convergence:
                break

        pot_tot = pot_tot[int(N/k):int(N+N/k),int(M/k):int(M+M/k)]
        if self.carrier_charge_sign==1: carrier_den = self.TF_holes(pot_tot,self.f_level)
        if self.carrier_charge_sign==-1: carrier_den = self.TF_electron(pot_tot,self.f_level)

        return pot_tot, carrier_den

    """This gives you path of minimum potential between drain and source points"""
    def get_path(self,pot,xp,yp):

        energy = self.potential_energy(pot)
        # Low res for fast path find (sl=1 is full res)
        sl = 1
        low_res_energy, low_res_pot = energy[::sl, ::sl], pot[::sl,::sl]
        vert, hor = low_res_energy.shape[0], low_res_energy.shape[1]

        #low_res_pot = low_res_pot[int(vert*1/4):int(vert*9.5/10), int(hor / 5):int(hor * 4 / 5)]
        #print("Shape of pot in get path: ", low_res_energy.shape)
        """Change source and drain location
        This is important, make sure that the points indicating your drain and source are in correct locations.
        """
        # Plot 2D path
        self.source = [int(0.326087 * low_res_energy.shape[0]), int(0.0336984 * low_res_energy.shape[1])]
        self.drain = [int(0.326087 * low_res_energy.shape[0]), int(low_res_energy.shape[1] - 0.0336984 * low_res_energy.shape[1])]

        # Find new 1D path
        path, path_map_scr = self.path_find(low_res_energy)

        one_d_path = low_res_energy[path[:, 0], path[:, 1]]

        ij_path = [np.arange(0, low_res_energy.shape[0])[path[:, 0]],
                   np.arange(0, low_res_energy.shape[1])[path[:, 1]]]

        # Define variables in self
        self.pot_path = one_d_path
        self.path_coords = path
        self.path_coords_ij = ij_path

        return low_res_pot

    """Calculates number of dots in the image"""
    def dot_count(self, pot, mu_f=0):
        # Counts the number of dots
        # Initialize to zero dots
        n_dot = 0
        # One dimensional potential path
        V = self.potential_energy(self.pot_path)
        # 2D potential energy
        energy = self.potential_energy(pot)
        #np.save("curve_fitting/pot_path.npy",V)
        # Find charge islands
        # Return equilibrium charge state
        M = len(V)

        i, j = 0, M - 1
        start, stop = V[i], V[j]
        # Choose starting points with non-zero electron density
        while start > mu_f or stop > mu_f:

            if start > mu_f:
                i = i + 1
            if stop > mu_f:
                j = j - 1
            start, stop = V[i], V[j]
            if i == M or j == 0:
                return 0

        # Move until carrier density is zero
        while start <= mu_f or stop <= mu_f:

            start, stop = V[i], V[j]
            if start <= mu_f:
                i = i + 1
            if stop <= mu_f:
                j = j - 1
            if i == M or j == 0:
                return 0
        space = np.arange(i, j, 1)
        island = np.zeros(M)
        # Mask array identifying charge islands
        for s in space:
            if V[s] < mu_f:
                island[s] = 1

        # Edges of islands
        boundaries = [0]
        for i in range(M - 1):
            if island[i] != island[i + 1]:
                boundaries.append(i)
        boundaries.append(M)
        # Location of Islands and Barriers
        n_region = len(boundaries)
        regions = np.zeros((n_region - 1, 2))
        for i in np.arange(1, n_region, 1):
            regions[i - 1] = np.array([boundaries[i - 1], boundaries[i]])
        # Locations of Islands (index)
        islands = np.array(regions[1::2]).astype(int)

        n_island = islands.shape[0]

        if n_island == 0:
            return n_dot

        # Centre of island
        centres = []
        for i in range(n_island):
            centres.append(int(np.mean(islands[i])))
        centres = np.array(centres)

        # Escape routes from "dot"
        n_dot = n_island
        escape_left = [int(1 * pot.shape[0] / 4), 1]
        escape_right = [int(1 * pot.shape[0] / 4), int(pot.shape[1]) - 2]
        escape_targets = [escape_left, escape_right]
        path_ij = np.array(self.path_coords_ij).T

        for i in range(n_island):
            escape = False
            small = False

            # Check for tiny dots
            if escape == False and (islands[i][1] - islands[i][0]) < 4:
                print('Small')
                small = True
                n_dot = n_dot - 1

            # Check for escape routes
            if small == False:
                self.source = path_ij[centres[i]].astype(int)

                for esc in escape_targets:

                    self.drain = esc

                    path, path_2d = self.path_find(energy)
                    one_d_path = energy[path[:, 0], path[:, 1]]

                    if np.max(one_d_path) < mu_f:
                        escape = True

                if escape == True:
                    print('Escaped')
                    n_dot = n_dot - 1

        source_list = []
        for i in range(n_island):
            source_list.append( path_ij[centres[i]].astype(int) )

        #if len(source_list)!=0: self.source_list = np.array(source_list)
        #else: self.source_list = None
        self.source_list = np.array(source_list) if len(source_list) != 0 else None

        return n_dot

    """ Estimated occupation of the dot"""
    def get_occupation(self,pot):
        n_charge = 0
        energy = self.potential_energy(pot)
        if self.source_list is not None:
            n_charge = []
            dots = []
            for seed in self.source_list:
                # Binary mask for electron density
                image = (energy<0)*1
                # Mask for single dot
                new_image = flood_fill(image, (seed[0],seed[1]), 2)
                mask = (new_image==2)*1
                # Charge density in dot
                if self.carrier_charge_sign==1: density = self.TF_holes(mask*pot)
                else: density = self.TF_electron(mask*pot)

                Nx = density.shape[1]
                Ny = density.shape[0]
                x = np.linspace(0, self.scale[0] * Nx, Nx)
                y = np.linspace(0, self.scale[1] * Ny, Ny)

                n_charge.append(np.trapz(np.trapz(density,x,axis=1),y))
                dots.append(density)
                
            n_charge = np.array(n_charge)
            
            #np.save("dots_alone.npy",dots[0]+dots[1])
            #plt.contourf(x, y,dots[0]+dots[1],levels=60,cmap='gist_stern')
            #plt.show()
        return n_charge

    def potential_energy(self,pot):
        return self.carrier_charge_sign*pot

    def get_scale(self,pot):
        # Determine length scales
        N = pot.shape[0]
        M = pot.shape[1]
        ly = 625*1.5
        lx = 934*1.5
        scale_og = np.array([lx / M, ly / N])  # nm
        # Average length scales based on measurements in x,y
        scale = scale_og
        y = np.arange(-ly / 2, ly / 2, scale[1])  # nm
        x = np.arange(-lx / 2, lx / 2, scale[0])  # nm
        self.scale = scale * 1E-9  # m
        self.x,self.y = x,y

    def crop(self,pot):
        # Zoom in on central region
        # Helps with path finding and reduces size of graph
        # Vertical
        # Top
        l_1 = int(pot.shape[0] * 0.5 / 12)
        # Bottom
        h_1 = int(pot.shape[0] * 12 / 12)
        #left
        l_2 = int(pot.shape[1] * 2.5 / 10)
        #right
        h_2 = int(pot.shape[1] * 8 / 10)

        #pot = pot[l_1:h_1, l_2:h_2]
        pot = pot[:,:]
        pot = np.flip(pot, axis=0)

        #xp = self.x[l_2:h_2]
        #yp = self.y[l_1:h_1]
        
        xp = self.x[:]
        yp = self.y[:]

        return pot,xp,yp
            
    def main(self,potential,plot=False):

        # Calculate potential landscape
        start = time.time()
        
        """
        This scaling factor is more like experimental factor to correct for charges inside the device
        you should based it on what you are measuring on gates ie when they have double dots or when there are no tunneling events
        """
        
        # scale_factor = 0.615
        scale_factor = 0.85
        
        pot_small_sum = self.weighted_potential(potential)
        pot_small_sum = pot_small_sum * scale_factor
        
        end = time.time()
        if self.information==True:
            print('Potential Time: %.3f s' %(end-start))
        
        self.get_scale(pot_small_sum)
        pot_small_sum,xp,yp = self.crop(pot_small_sum)
        X,Y = np.meshgrid(xp,yp)
        
        
        if self.add_disorder==True:
            dis = self.disorder(pot_small_sum)
        else:
            dis = self.pot_dis
        
        """
        Surface value based on density figure when voltages are zero. You should see ellipses in the centre of image
        """
        # Total potential
        surface = -307
        pot_tot = pot_small_sum + surface
        # Low res for fast path find (sl=1 is full res)
        sl = 1
        low_res_pot = pot_tot[::sl,::sl]
        vert,hor = low_res_pot.shape[0],low_res_pot.shape[1]
        xp_copy, yp_copy = copy.deepcopy(xp), copy.deepcopy(yp)
        
        xp,yp = xp[::sl],yp[::sl]
        #xp,yp = xp[int(hor/5):int(hor*4/5)], yp[int(vert*1/4):int(vert*9.5/10)]
        
        LR_X, LR_Y = np.meshgrid(xp,yp)

       
        if self.information==True:
            print('Length Scale (m):',self.scale)
            print('Disorder Time:\t%.3f s' %(end-start))

        ###############################################################

        # SCREENING
        if self.screen == True:
            
            start = time.time()
            scr_pot, carrier_den = self.screening(pot_tot)
            end = time.time()
            """
            #print(f"Time for carrier den: {end-start}")
            #print('Screen Time', end-start)
            low_res_scr_pot = scr_pot[::sl,::sl]
            low_res_scr_pot = self.get_path(low_res_scr_pot,xp_copy,yp_copy)
            # Estimate Fermi level based on pinch off
            minimax,min_point = self.minimax_point()
            # Count the dots
            n_dot = self.dot_count(low_res_scr_pot)
            # Dot occupation
            occupation = self.get_occupation(low_res_scr_pot)
            """
            plot_density(np.flipud(carrier_den[5:-5,5:-5]), "Initial Hole Density Map", )

            self.information = False
            if self.information==True:
                print('\nMean Electron Density:\t\t%.3e m^-2' %np.mean(carrier_den))
                print('Potential Standard Deviation:\t%.3e mV' %np.std(scr_pot))
                plt.figure(figsize=(8,6))
                #plt.title('1D Path: Source -> Drain, scale factor = '+str(scale_factor),fontsize=20)
                plt.title('1D Path: Source -> Drain',fontsize=20)
                plt.plot(range(len(self.path_coords)), self.pot_path,'b-')
                plt.plot(np.ones(len(self.path_coords))*-1*self.f_level,'r--')
                plt.xlabel('Step Number', fontsize=16)
                plt.ylabel('Potential Energy ['+ r'$meV$'+']',fontsize=16)
                #plt.savefig(self.configuration+"/"+self.file+"_1D_path.png")

                plt.figure(figsize=(10,6))
                plt.title('Screened Potential, scale factor = '+str(scale_factor),fontsize=20)
                
                plt.title('Screened Potential',fontsize=20)
                plt.contour(LR_X,LR_Y,low_res_scr_pot,levels=50)
                plt.scatter(xp[self.path_coords_ij[1]],yp[self.path_coords_ij[0]],cmap='Greys', alpha=0.7)
                plt.scatter(xp[min_point[0]],yp[min_point[1]],s=80,c='r')
                plt.xlabel('x ['+ r'$nm$'+']',fontsize=16)
                plt.ylabel('y ['+ r'$nm$'+']',fontsize=16)
                #plt.savefig(self.configuration+"/"+self.file+"_Screened_potential_path.png")
                plt.colorbar()

                plt.figure(figsize=(10,6))
                #plt.title('scale factor = '+str(scale_factor),fontsize=20)
                plt.contourf(X, Y,carrier_den,levels=60,cmap='gist_stern')
                plt.xlabel('x ['+ r'$nm$'+']',fontsize=16)
                plt.ylabel('y ['+ r'$nm$'+']',fontsize=16)
                plt.text(.5,.05,"Gates: " + str(self.gate_volt), ha = "center")
                cbar = plt.colorbar()
                cbar.set_label("Hole Density ["+r'$m^{-2}$' "]",fontsize=14)
                cbar.ax.set_ylim(carrier_den.min(),1.44*10**16)
                #plt.savefig(self.configuration+"/"+self.file+"_hole_density.png")
                #print('Number of Dots:',n_dot)
                #print('Occupation:',occupation)
                #print('Integer Occupation:',np.floor(occupation))
                plt.show()
                
                
                #self.plot_potential(carrier_den,title="Hole density",save="img/hole_density_poster.pdf")

        voltages = self.gate_volt
        #min_loc = np.array([ np.round(xp[min_point[0]],3),np.round(yp[min_point[1]],3) ])
        #results = {'voltages':voltages,'gates':pot_small_sum,'disorder':(dis+surface),
        #            'screened':scr_pot, 'minimax_value':minimax,'minimax_loc':min_loc,
        #            'density':carrier_den,'n_dot':n_dot, 'occupation':occupation }
        #results = {'voltages':voltages,'screened':scr_pot, 'density':carrier_den, 'minimax_value':minimax,'minimax_loc':min_loc,'path':self.path_coords_ij, 'n_dot':n_dot, 'occupation':occupation, 'energy': self.pot_path, 'scale_factor':scale_factor, 'surface': surface }
        
        #results = {'screened':scr_pot}
        
        return self.pot_with_applied_voltages, carrier_den


def plot_density(img, title, save=None, mV=False, show=True):
    class OOMFormatter(matplotlib.ticker.ScalarFormatter):
        def __init__(self, order=0, fformat="%1.1f", offset=True, mathText=True):
            self.oom = order
            self.fformat = fformat
            matplotlib.ticker.ScalarFormatter.__init__(self, useOffset=offset, useMathText=mathText)
        def _set_order_of_magnitude(self):
            self.orderOfMagnitude = self.oom
        def _set_format(self, vmin=None, vmax=None):
            self.format = self.fformat
            if self._useMathText:
                self.format = r'$\mathdefault{%s}$' % self.format
 
    col = ['#1BE7D0', '#e635f9', '#DFFF00', '#EFFFFE']
    cmap = plt.get_cmap("jet", 30)
    im_ratio = img.shape[0] / img.shape[1]
    im = plt.imshow(img, cmap=cmap, extent=(0, img.shape[1], 0, img.shape[0]), interpolation='none')
    
    plt.title(title, fontsize=14)
    plt.xlabel("x [px]", fontsize=14)
    plt.ylabel("y [px]", fontsize=14)
    
    im.axes.spines.left.set_color(col[1])
    im.axes.spines.right.set_color(col[1])
    im.axes.spines.top.set_color(col[0])
    im.axes.spines.bottom.set_color(col[0])
    im.axes.tick_params(axis="x")
    im.axes.tick_params(axis="y")
    
    min_val = np.amin(img)
    max_val = np.amax(img)

    print(max_val)
    print(img.shape[0], img.shape[1])
    """
    if not mV:
        ticks = np.array([0.0,2*10**15,4*10**15,6*10**15,8*10**15,10*10**15,12*10**15,max_val])
    else:
    """
    
    num_ticks = 6  # Adjust this for better spacing
    ticks = np.linspace(0, max_val, num_ticks)
    #ticks = np.insert(ticks, 0, min_val)
    #ticks = np.append(ticks, max_val)
    
    cb = plt.colorbar(im, fraction=0.047 * im_ratio, ticks=ticks, orientation="vertical", format=OOMFormatter(15))
    
    plt.setp(plt.getp(cb.ax.axes, 'yticklabels'))
    
    cb.ax.set_ylabel("Hole density ["+r'$m^{-2}$' "]",fontsize=14)
    if save != None:
        plt.savefig(save, bbox_inches='tight', transparent=True, facecolor="black")
    if show:
        plt.show()

"""
Here you calculate potential of the gates.

Separation is array of n number of images where each image is one gate of the device.
Check load gates to see how the array looks like.

"""
def preprocess_new(separation):
    separation = np.moveaxis(separation,0,-1)
    separation = np.abs(separation - np.ones_like(separation))
    
    
    data = np.sum(separation,axis=2)

    potential = calc_potential_eachgate(separation, data)
    
    
    """
    plt.figure(figsize=(12, 6))

    # Plot separation
    plt.subplot(1, 2, 1)
    plt.imshow(separation[:,:,5], cmap='viridis')
    plt.title('Gate with binary values')

    # Plot potential
    plt.subplot(1, 2, 2)
    plt.imshow(potential[:,:,5], cmap='plasma')
    plt.title('Potential of the gate')

    plt.tight_layout()
    plt.savefig("a_comparison_of_gates.png")
    #plt.show()
    """
    return potential

"""
Here is example function to load gates. I used SEM image of the device to redraw each gate.
I have made code to go from SEM image to this too, but I haven't tested it much.
"""

def load_gates():
    SEM_c = True
    SEM = ""
    if SEM_c:
        SEM = "../gate_images/SEM_"
    else:
        SEM = ""
    img1 = np.where(imread(SEM+"gate_0.png")[:,:,3] > 50, 255, 0)
    img2 = np.where(imread(SEM+"gate_1.png")[:,:,3] > 50, 255, 0)
    img3 = np.where(imread(SEM+"gate_2.png")[:,:,3] > 50, 255, 0)
    img4 = np.where(imread(SEM+"gate_3.png")[:,:,3] > 50, 255, 0)
    img5 = np.where(imread(SEM+"gate_4.png")[:,:,3] > 50, 255, 0)
    #img6 = np.where(imread(SEM+"gate_5.png")[:,:,3] > 50, 255, 0)
    #img7 = np.where(imread(SEM+"gate_6.png")[:,:,3] > 50, 255, 0)
    #img8 = np.where(imread(SEM+"gate_7.png")[:,:,3] > 50, 255, 0)
    #img9 = np.where(imread(SEM+"gate_8.png")[:,:,3] > 50, 255, 0)
    #img10 = np.where(imread(SEM+"gate_9.png")[:,:,3] > 50, 255, 0)

    #gates_design = np.array([img1, img2, img3, img4, img5, img6, img7, img8, img9, img10])
    gates_design = np.array([img1, img2, img3, img4, img5])

    lx = gates_design.shape[1]
    ly = gates_design.shape[2]

    gates_design = gates_design[:, int(lx/6):int(5*lx/6), int(ly/6):int(5*ly/6)]

    l_1 = int(gates_design.shape[1] * 0.5 / 12)
    h_1 = int(gates_design.shape[1] * 12 / 12)
    l_2 = int(gates_design.shape[2] * 2.5 / 10)
    h_2 = int(gates_design.shape[2] * 8 / 10)


    gates_design = gates_design[:, l_1:h_1, l_2:h_2]  # Resolution: 399 x 343
    # gates_design = gates_design[:, ::2, ::2]

    return gates_design


"""
I am using this function get_physical_density in my RL algorithm to get both potential and density.
Rename it to main, when you want to run it or just call this function. It needs geometry ie image of gates and voltages.

You can see how I load gates in the function load_gates above. It also crops the image to make it smaller for calculation.
You can delete the crop part or adjust it as needed for device you are using.

"""
def get_physical_density(geometry,var_volt=0):
    
    t1 = time.time()
    potential = preprocess_new(geometry)
    t2 = time.time()

    print(f"Time for preprocess_new: {t2 - t1}")

    pp = potential_path()
    pp.information = True
    pp.physics_potential = potential
    
    
    #pp.gate_volt = np.array([4000,2000,1800,1800,4000,1550,4000,1500,3100,1250])
    #pp.gate_volt = np.array([3500,1360,1513,1201,3500,1330,3506,910,2686,1080])
    pp.gate_volt = np.array(var_volt)
    
    results = pp.main(potential)
    
    t3 = time.time()
    #print(f"Gates with shape {geometry.shape}, Potential: {t2-t1}, Density:{t3-t2}, Total: {t3-t1}")
    pp = ""
    return results

    
   
if __name__ == '__main__':
    """
    gate_design = np.load("decreasing_gate_size_potential_samples.npy",allow_pickle=True)
    potential = gate_design.get("potential")
    data = []
    for i in range(10):
        data.append(main(potential[i]))
        
    pickle.dump(data,open("test.npy","wb"),protocol=4)
    """
    
    """
    gates_limits = np.array(([3200,3800],[1200,1600],[2000,2500],[1100,1500],[3200,3800],[900,1700],[2500,4000],[700,1500],[2200,3500],[800,1500]))
    checks = []
    for i in range(20000):
        gate_volt_random = []
        for i in range(10):
            gate_volt_random.append(np.random.randint(gates_limits[i][0],gates_limits[i][1]))
        checks.append(np.array(gate_volt_random))
    """
    
    gates = load_gates()
    t1 = time.time()
    #preprocess_new(gates)
    #voltages = np.array([4000,2000,1800,1800,4000,1550,4000,1500,3100,1250])
    voltages = np.array([4000,4000,3000,3000,3000])
    get_physical_density(gates,voltages)
    pot_time = time.time() - t1
    
    print(f"Gates with shape {gates.shape} needed time: {pot_time}")
    
    """
    gate_design = np.load("decreasing_heigth_all_samples.npy",allow_pickle=True)
    potential = gate_design.get("potential")
    
    data = []
    t1 = time.time()
    with Pool() as p:
        results = p.map(main, potential)
        data.append(results)
    
    Pool_time = time.time()-t1
    print("Pool time: ",Pool_time)
    
    pickle.dump(data,open("results_all_sf615.npy","wb"),protocol=4)
    #pickle.dump(a,open("potential_img_half.npy","wb"),protocol=4)
    #np.save("results/data_array.npy",np.asarray(data))
    """